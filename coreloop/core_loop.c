#include <string.h> // Add include for memcpy
#include <stdlib.h>
#include <stdint.h>
#include "LuSEE_IO.h"
#include "LuSEE_SPI.h"
#include "LuSEE_Flash_cntrl.h"
#include "core_loop.h"
#include "spectrometer_interface.h"
#include "cdi_interface.h"
// autogenerated include files from documentation
#include "lusee_commands.h"
#include "lusee_appIds.h"


/***************** GLOBAL STATE ******************/

struct core_state state;
uint16_t avg_counter = 0;
uint32_t unique_packet_id;
uint8_t leading_zeros_min[NSPECTRA];
uint8_t leading_zeros_max[NSPECTRA];
uint8_t housekeeping_request;
uint32_t section_break;
uint8_t range_adc, resettle, request_waveform; 
bool tick_tock;
bool drop_df;
bool soft_reset_flag;

uint32_t heartbeat_packet_count;

// thing that are touched in the interrupt need to be proclaimed volatile
volatile uint32_t heartbeat_counter;
volatile uint32_t resettle_counter;
uint16_t flash_store_pointer;


// FLASH constrol
volatile uint32_t flash_clear;
volatile uint32_t flash_write;
volatile uint32_t flash_addr;
void* flash_buf;
volatile uint32_t flash_size;
volatile uint32_t flash_wait;

struct saved_core_state tmp_state;



/**************************************************/



/************* CODE STARTS HERE **************************************/
#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))




void cdi_not_implemented(const char *msg)
{
    debug_print("CDI command not implemented: ");
    debug_print(msg);
    debug_print("\n\r")
    return;
}


uint32_t print_buf(const void* data, size_t size) {
    uint8_t *b = (uint8_t *)(data);
    for (int i=0; i<size; i++) {
        debug_print_hex(b[i]);
        debug_print(" ");
    }
    debug_print("\r\n")
}



void set_flash_addr (uint32_t slot) {
    flash_addr = slot*PAGES_PER_SLOT*256 + Flash_Recov_Region_1;
}


void flash_state_clear(uint8_t slot) {
   // need to clear just the first 4 bytes;
    set_flash_addr(slot);
    flash_clear = 4;
}




void flash_state_store (uint8_t slot) {
    debug_print("Storing state to slot ");
    debug_print_dec(slot);
    debug_print("\r\n");
    tmp_state.in_use = 0xBEBEC;

    tmp_state.state = state;
    /*uint8_t* b = (uint8_t *)(&tmp_state.state);
    for (int i=0;i<sizeof(struct core_state);i++) b[i] = i%0xff;*/

    tmp_state.CRC = CRC(&tmp_state.state,sizeof(struct core_state));
    //debug_print("CRC:");
    //debug_print_hex(tmp_state.CRC);
    //debug_print("\r\n");
    //print_buf(&tmp_state,sizeof(tmp_state));
    set_flash_addr(slot);
    flash_buf = &tmp_state;
    flash_size = sizeof(tmp_state);
    flash_clear = 4;
}


void  Read_Flash_uC (uint32_t size) {
    // cannot reuse flash_size, since this would trigger write in the interrupt!!
    while (size>0) {
        //debug_print("flash read ")
        //debug_print_dec(size);
        //debug_print (" ");
        //debug_print_hex(flash_addr);
        //debug_print("\r\n");

        SPI_read_page(flash_addr);  //opcode 03h  read page

        uint32_t tocpy = (size<=256) ? size : 256;
        memcpy (flash_buf, SFL_RD_BUFF, tocpy);
        if (size>256) size-=256; else size=0;
        flash_addr += 256;
        flash_buf += 256;
    }
}


bool flash_state_restore(uint8_t slot) {
    // try to restore state from flash
    // return true if successful 
    //memset(&tmp_state, 0,  sizeof(tmp_state));
    set_flash_addr(slot);
    flash_buf = &tmp_state;
    Read_Flash_uC(sizeof(uint32_t)); // first read just a little bit
    //debug_print ("in use:")
    //debug_print_hex (tmp_state.in_use);
    //debug_print ("\r\n")
    if (tmp_state.in_use == 0xBEBEC) {
        debug_print("Found an occuped slot ");
        debug_print_dec(slot);
        debug_print("\r\n");

        set_flash_addr(slot);
        flash_buf = &tmp_state;
        Read_Flash_uC(sizeof(tmp_state));
        //print_buf(&tmp_state,sizeof(tmp_state));

        uint32_t crc = CRC(&tmp_state.state,sizeof(struct core_state));
        //debug_print_hex(tmp_state.CRC);
        //debug_print (" ");
        //debug_print_hex(crc);

        if (crc == tmp_state.CRC) {
         // VICTORY
            debug_print(" CRC match, buying \r\n");
            state = tmp_state.state;
            return true;
        }
        debug_print(" CRC fail ?! \r\n");
        state.base.errors |= FLASH_CRC_FAIL;
        return false;
     }
    return false;
 }


void debug_helper(uint8_t arg) {
    flash_state_restore(arg);
}



static inline void new_unique_packet_id()
{
    unique_packet_id++;
}



static inline void update_time() {
    // why is this not working is not clear.
    //spec_get_time(&state.base.time_seconds, &state.base.time_subseconds);
    uint32_t sec;
    uint16_t subsec;
    spec_get_time(&sec, &subsec);
    state.base.time_seconds = sec;
    state.base.time_subseconds = subsec;
    state.base.rand_state += sec;
}

void send_hello_packet() {
    debug_print ("Sending hello packet.\n\r")
    struct startup_hello *payload = (struct startup_hello*) (TLM_BUF);
    new_unique_packet_id();
    update_time();
    wait_for_cdi_ready();
    payload->SW_version = VERSION_ID;
    payload->FW_Version = spec_get_version(0);;
    payload->FW_ID = spec_get_version(1);
    payload->FW_Date = spec_get_version(2);
    payload->FW_Time = spec_get_version(3);
    payload->unique_packet_id = unique_packet_id;
    payload->time_seconds = state.base.time_seconds;
    payload->time_subseconds = state.base.time_subseconds;
    cdi_dispatch(AppID_uC_Start, sizeof(struct startup_hello));
}

bool process_hearbeat() {
    if (heartbeat_counter > 0) return false;
    debug_print("Sending heartbeat.\n\r");
    wait_for_cdi_ready();
    char *msg = (char *) TLM_BUF;
    * ((uint32_t*)(TLM_BUF))  =  heartbeat_packet_count;
    heartbeat_packet_count++;
    msg[4] = 'B';
    msg[5] = 'R';
    msg[6] = 'R';
    msg[7] = 'L';

    cdi_dispatch(AppID_uC_Heartbeat, 8);
    heartbeat_counter = HEARTBEAT_DELAY;
    return true;
}



void set_spectrometer_to_sequencer()
{
    for (int i = 0; i < NINPUT; i++) {
        //if (state.seq.gain[i]!=GAIN_AUTO)  // not needed and can break initialization
        spec_set_gain(i, state.base.actual_gain[i]);
        spec_set_route(i, state.seq.route[i].plus, state.seq.route[i].minus);
    }
    spec_set_bitslice(state.base.actual_bitslice);
    spec_set_avg1 (state.seq.Navg1_shift);
    spec_notch_enable(state.seq.notch);
    return;
}


void default_seq (struct sequencer_state *seq)
{
    for (int i = 0; i < NINPUT; i++) {
        seq->gain[i] = GAIN_MED;
        seq->route[i].plus = i;
        seq->route[i].minus = 0xFF;
        seq->gain[i] = GAIN_MED;
        seq->gain_auto_min[i] = (1 << 7);
        seq->gain_auto_mult[i] = (1 << 4);
    }
    seq->Navg1_shift = 14;
    seq->Navg2_shift = 3;
    seq->Navgf = 1;
    for (int i = 0; i < NSPECTRA; i++) seq->bitslice[i]=0x1F;
    seq->notch = 0;
    seq->hi_frac = 0xFF;
    seq->med_frac = 0x00;
    seq->bitslice_keep_bits=13;
    seq->format =  OUTPUT_32BIT; // OUTPUT_16BIT_UPDATES;
    seq->reject_ratio = 0; // no rejection by default
    seq->reject_maxbad = 0;


}

void fill_derived() {
    state.Navg1 = 1 << state.seq.Navg1_shift;
    state.Navg2 = 1 << state.seq.Navg2_shift;
    state.tr_avg = 1 << state.seq.tr_avg_shift; 
    // total shift takes into account frequency averaging;
    state.Navg2_total_shift = state.seq.Navg2_shift;
    state.Nfreq = NCHANNELS; 
    if (state.seq.Navgf == 2 ) { state.Navg2_total_shift += 1; state.Nfreq = NCHANNELS/2; }
    if ((state.seq.Navgf == 3 ) || (state.seq.Navgf == 4)) { state.Navg2_total_shift += 2; state.Nfreq = NCHANNELS/4;} 
    for (int i=0; i<NINPUT; i++) {
        state.gain_auto_max[i] = (state.seq.gain_auto_min[i] * state.seq.gain_auto_mult[i]);
    }   
}

void core_init_state(){   
    default_seq (&state.seq);
    state.base.errors = 0;
    state.base.corr_products_mask=0b1111111111111111; //65535
    state.base.spectrometer_enable = false;
    state.base.rand_state = 0xFEEDD0D0;
    spec_set_spectrometer_enable(false);
    housekeeping_request = 0;
    range_adc = 0;
    for (int i=0; i<NINPUT; i++) state.base.actual_gain[i] = GAIN_MED;
    for (int i=0; i<NSPECTRA; i++) state.base.actual_bitslice[i] = MIN(state.seq.bitslice[i],0x1F); // to convert FF to 16
    spec_set_spectrometer_enable(false);
    state.base.sequencer_step = 0xFF;
    state.sequencer_enabled = false;
    state.program.Nseq = 0;
    state.cdi_dispatch.prod_count = 0xFF; // >0F so disabled.
    tick_tock = true;
    state.base.weight_current = state.base.weight_previous = 0;
    drop_df = false;
    update_time();
    unique_packet_id = state.base.time_seconds;
    fill_derived();

    set_spectrometer_to_sequencer();
    heartbeat_counter = HEARTBEAT_DELAY;
}

void reset_errormasks() {
    state.base.errors = 0;
    state.base.spec_overflow = 0;
    state.base.notch_overflow = 0;
}


void RFS_stop() {
    debug_print ("Stopping spectrometer\n\r");
    state.base.spectrometer_enable = false;
    spec_set_spectrometer_enable(false);
}


void RFS_start() {
    debug_print ("Starting spectrometer\n\r");
    state.base.spectrometer_enable = true;
    avg_counter = 0;
    memset((void *)SPEC_TICK, 0, NSPECTRA*NCHANNELS * sizeof(uint32_t));
    memset((void *)SPEC_TOCK, 0, NSPECTRA*NCHANNELS * sizeof(uint32_t));
    if (state.sequencer_enabled) {
        state.base.sequencer_counter = 0;
        state.base.sequencer_step = 0;
        state.base.sequencer_substep = state.program.seq_times[0];
        state.seq = state.program.seq[0];
    }
    fill_derived();
    set_spectrometer_to_sequencer();
    spec_set_spectrometer_enable(true);
    //drop_df = true;
}


void restart_spectrometer()
{
    RFS_stop();
    RFS_start();
}

void trigger_ADC_stat() {
    spec_trigger_ADC_stat(ADC_STAT_SAMPLES);
}

void update_spec_gains() {
    for (int8_t i = 0; i < NINPUT; i++) {
        spec_set_gain(i, state.base.actual_gain[i]);
    }
    debug_print("gains changed\r\n");
}

bool restart_needed (struct sequencer_state *seq1, struct sequencer_state *seq2 ) {    
    if (seq1->notch != seq2->notch) return true;
    for (int i=0; i<NINPUT; i++) { 
        if (seq1->gain[i] != seq2->gain[i]) return true;
        if (seq1->route[i].plus != seq2->route[i].plus) return true;
        if (seq1->route[i].minus != seq2->route[i].minus) return true;
    }
    for (int i=0; i<NSPECTRA; i++) if (seq1->bitslice[i] != seq2->bitslice[i]) return true;
    return false;
}

void set_route (uint8_t ch, uint8_t arg_low) {
    state.seq.route[ch].plus = arg_low & 0b111;
    state.seq.route[ch].minus = ((arg_low & 0b111000) >> 3);
    uint8_t gain = ((arg_low & 0b11000000) >> 6);
    spec_set_route(ch, state.seq.route[ch].plus, state.seq.route[ch].minus);
    state.seq.gain[ch] = gain;
    state.base.actual_gain[ch] = gain;
    spec_set_gain(ch, state.base.actual_gain[ch]);
}



inline static bool process_cdi()
{
    uint8_t cmd, arg_high, arg_low;
    uint8_t ch, xcor, val;
    uint8_t ant1low, ant1high, ant2low, ant2high, ant3low, ant3high, ant4low, ant4high;
    if (!cdi_new_command(&cmd, &arg_high, &arg_low)) return false;
    debug_print ("Got new CDI command: ");
    debug_print_hex(arg_high);
    debug_print(" ");
    debug_print_hex(arg_low);
    debug_print("\r\n");

    if (cmd==RFS_Settings)  {
        switch (arg_high) {
            case RFS_SET_START:
                if (!state.base.spectrometer_enable) {
                    RFS_start();
                    flash_store_pointer = heartbeat_counter%MAX_STATE_SLOTS;
                    flash_state_store(flash_store_pointer);
                }
                break;
            case RFS_SET_STOP:
                if (state.base.spectrometer_enable) {
                    flash_state_clear(flash_store_pointer);
                    RFS_stop();
                }
                break;                
            case RFS_SET_RESET:
                RFS_stop();
                spec_set_reset();
                spec_write_uC_register(0,arg_low);
                soft_reset_flag = true;
                return true;
            case RFS_SET_STORE:
                spec_store();
                break;
            case RFS_SET_RECALL:
                spec_recall();
                break;
            case RFS_SET_HK_REQ:            
                if ((arg_low < 2) || (arg_low == 99)) {
                    housekeeping_request = 1+arg_low; 
                } else {
                    state.base.errors |= CDI_COMMAND_BAD_ARGS;
                }
                break;

            case RFS_SET_RANGE_ADC:
                range_adc = 1;
                trigger_ADC_stat();           
                break;

            case RFS_SET_WAVEFORM:
                if (arg_low<4) request_waveform = arg_low | 4;
                else state.base.errors |= CDI_COMMAND_BAD_ARGS;
                break;

            case RFS_SET_DEBUG:
                debug_helper(arg_low);
                break;

            case RFS_SET_TIME_TO_DIE:
                debug_print("Recevied time-to-die.\n\r")
                return true;

            case RFS_SET_LOAD_FL:
                // load the sequencer program # arg_low (0-255) into state.program
                cdi_not_implemented("RFS_SET_LOAD_FL");
                break;
            case RFS_SET_STORE_FL:
                // store the sequencer program # arg_low (0-255) from state.program into flash
                cdi_not_implemented("RFS_SET_STORE_FL");
                break;

            case RFS_SET_GAIN_ANA_SET:                
                for (int i=0; i<NINPUT; i++){
                    uint8_t val = (arg_low >> (2*i)) & 0x03;
                    if (val==3) {
                        if  (state.seq.gain[i] != GAIN_DISABLE){
                            state.seq.gain[i] = GAIN_AUTO;
                        }
                    } else {
                       state.seq.gain[i] = val;
                        state.base.actual_gain[i] = val;
                    }
                }
                update_spec_gains();
                break;

            case RFS_SET_DISABLE_ADC:
                for (int i=0; i<NINPUT; i++){
                    if ((arg_low >> (i)) & 0x01) {
                        state.seq.gain[i] = GAIN_DISABLE;
                        state.base.actual_gain[i] = GAIN_DISABLE;
                    }
                }
                update_spec_gains();
                break;

            case RFS_SET_GAIN_ANA_CFG_MIN:
                ch = arg_low & 0x03;
                val = (arg_low & 0xFC) >> 2;
                state.seq.gain_auto_min[ch] = 16*val; //max 16*64 = 1024, which is 1/8th
                break;
            case RFS_SET_GAIN_ANA_CFG_MULT:
                ch = arg_low & 0x03;
                val = (arg_low & 0xFC) >> 2;
                state.seq.gain_auto_mult[ch] = val;
                break;
            case RFS_SET_BITSLICE_LOW:
                xcor = arg_low & 0x07;
                val = (arg_low & 0xF8) >> 3;
                state.seq.bitslice[xcor] = val;
                state.base.actual_bitslice[xcor] = val;
                break;
            case RFS_SET_BITSLICE_HIGH:
                xcor = (arg_low & 0x07) + 8;
                val = (arg_low & 0xF8) >> 3;
                state.seq.bitslice[xcor] = val;
                state.base.actual_bitslice[xcor] = val;
                break;
            case RFS_SET_BITSLICE_AUTO:
                if (arg_low > 0) {
                    for (int i=0; i<NSPECTRA; i++) state.seq.bitslice[i] = 0xFF;
                    state.seq.bitslice_keep_bits = arg_low;
                } else {
                    for (int i=0; i<NSPECTRA; i++) state.seq.bitslice[i] = 0x1F;
                }
                break;

            case RFS_SET_ROUTE_SET1:
                set_route (0, arg_low);
                break;

            case RFS_SET_ROUTE_SET2:
                set_route (1, arg_low);
                break;

            case RFS_SET_ROUTE_SET3:
                set_route (2, arg_low);
                break;

            case RFS_SET_ROUTE_SET4:
                set_route (3, arg_low);
                break;


            case RFS_SET_AVG_SET:
                state.seq.Navg1_shift = arg_low & 0x0F;
                state.seq.Navg2_shift = (arg_low & 0xF0) >> 4;

                fill_derived();
                break;
            case RFS_SET_AVG_FREQ:
                state.seq.Navgf = arg_low;
                fill_derived();
                break;
            case RFS_SET_AVG_NOTCH:
                state.seq.notch = arg_low;
                break;
            case RFS_SET_AVG_SET_HI:
                state.seq.hi_frac = arg_low;
                break;
            case RFS_SET_AVGI_SET_MID:
                state.seq.med_frac = arg_low;
                break;
            case RFS_SET_OUTPUT_FORMAT:
                if (arg_low > 2) {
                    state.base.errors |= CDI_COMMAND_BAD_ARGS;
                } else {
                    state.seq.format = arg_low;
                }
                break;

            case RFS_SET_PRODMASK_LOW:
                state.base.corr_products_mask = (state.base.corr_products_mask & 0xFF00) | arg_low;
                break;
            case RFS_SET_PRODMASK_HIGH:
                state.base.corr_products_mask = (state.base.corr_products_mask & 0x00FF) | (arg_low << 8);
                break;

            case RFS_SET_REJ_SET:
                state.seq.reject_ratio = arg_low;
                break;
            case RFS_SET_REJ_NBAD:
                state.seq.reject_maxbad = arg_low;
                break;
            case RFS_SET_TR_START_LSB:
                state.seq.tr_start = ((state.seq.tr_start & 0xFF00) +arg_low);
                break;  
            case RFS_SET_TR_STOP_LSB:
                state.seq.tr_stop = ((state.seq.tr_stop & 0xFF00) +arg_low);
                break;
            case RFS_SET_TR_ST_MSB:
                state.seq.tr_start = ((state.seq.tr_start & 0x00FF) + ((arg_low & (0x0F)) << 8));
                state.seq.tr_stop = ((state.seq.tr_stop & 0x00FF) + ((arg_low & (0xF0)) << 4));
                break;
            case RFS_SET_TR_AVG_SHIFT:
                state.seq.tr_avg_shift = arg_low;
                state.tr_avg = 1 << state.seq.tr_avg_shift;
                break;

            
            case RFS_SET_CAL_FRAC_SET:
                cdi_not_implemented("RFS_SET_CAL_FRAC_SET");
                break;
            case RFS_SET_CAL_MAX_SET:
                cdi_not_implemented("RFS_SET_CAL_MAX_SET");
                break;
            case RFS_SET_CAL_LOCK_SET:
                cdi_not_implemented("RFS_SET_CAL_LOCK_SET");
                break;
            case RFS_SET_CAL_SNR_SET:
                cdi_not_implemented("RFS_SET_CAL_SNR_SET");
                break;
            case RFS_SET_CAL_BIN_ST:
                cdi_not_implemented("RFS_SET_CAL_BIN_ST");
                break;
            case RFS_SET_CAL_BIN_EN:
                cdi_not_implemented("RFS_SET_CAL_BIN_EN");
                break;
            case RFS_SET_CAL_ANT_MASK:
                cdi_not_implemented("RFS_SET_CAL_ANT_MASK");
                break;
            case RFS_SET_ZOOM_EN:
                cdi_not_implemented("RFS_SET_ZOOM_EN");
                break;
            case RFS_SET_ZOOM_SET1:
                cdi_not_implemented("RFS_SET_ZOOM_SET1");
                break;
            case RFS_SET_ZOOM_SET1_LO:
                cdi_not_implemented("RFS_SET_ZOOM_SET1_LO");
                break;
            case RFS_SET_ZOOM_SET1_HI:
                cdi_not_implemented("RFS_SET_ZOOM_SET1_HI");
                break;
            case RFS_SET_ZOOM_SET2:
                cdi_not_implemented("RFS_SET_ZOOM_SET2");
                break;
            case RFS_SET_ZOOM_SET2_LO:
                cdi_not_implemented("RFS_SET_ZOOM_SET2_LO");
                break;
            case RFS_SET_ZOOM_SET2_HI:
                cdi_not_implemented("RFS_SET_ZOOM_SET2_HI");
                break;
            case RFS_SET_SEQ_EN:
                if (state.base.spectrometer_enable) {
                    state.base.errors |= CDI_COMMAND_BAD;
                } else {
                    state.sequencer_enabled = (arg_low>0);
                }
                break;
            case RFS_SET_SEQ_REP:
                if (state.base.spectrometer_enable) {
                    state.base.errors |= CDI_COMMAND_BAD;
                } else {
                    state.program.sequencer_repeat = arg_low;
                }
                break;
            case RFS_SET_SEQ_CYC:
                if (state.base.spectrometer_enable) {
                    state.base.errors |= CDI_COMMAND_BAD;
                } else {
                    state.program.Nseq = arg_low;
                    state.base.sequencer_step = 0;
                }
                break;
            case RFS_SET_SEQ_STO:
                if (state.base.spectrometer_enable) {
                    state.base.errors |= CDI_COMMAND_BAD;
                } else {
                    state.program.seq[state.base.sequencer_step] = state.seq;
                    state.program.seq_times[state.base.sequencer_step] = arg_low;
                    state.base.sequencer_step++;
                }
                break;
                
            default:
                debug_print ("UNRECOGNIZED RFS_SET COMMAND\n\r");
                state.base.errors |= CDI_COMMAND_UNKNOWN;
                break;
        } 
    } else {
        debug_print ("   Commmand not implemented, ignoring.\n\r");
        state.base.errors |= CDI_COMMAND_UNKNOWN;
    }
    return false;
}


bool analog_gain_control() {

    bool gains_changed = false;
    
    for (int i = 0; i < NINPUT; i++) {
        if (state.seq.gain[i] != GAIN_AUTO) continue; // Don't do anything unless AGC is enabled
        int32_t cmax = MAX(state.base.ADC_stat[i].max-0x1FFF, state.base.ADC_stat[i].min-0x1FFF);
        if ((state.base.
                ADC_stat[i].invalid_count_max>0) || (state.base.ADC_stat[i].invalid_count_min>0)) cmax = 10000; // blow through.
        //debug_print("AGC: Channel %i max = %i (%i %i) \n", i, cmax, state.gain_auto_max[i], state.seq.gain_auto_min[i]);
        if (cmax > state.gain_auto_max[i]) {
            if (state.base.actual_gain[i] > GAIN_LOW) {
                debug_print_dec(i);
                state.base.actual_gain[i] --;
                state.base.errors |= ((ANALOG_AGC_ACTION_CH1) << i);
                gains_changed = true;
            } else {
                state.base.errors |= (ANALOG_AGC_TOO_HIGH_CH1 <<i);
            }
        } else if (cmax < state.seq.gain_auto_min[i]) {
            if (state.base.actual_gain[i] < GAIN_HIGH) {
                debug_print_dec(i);

                state.base.actual_gain[i] ++;
                state.base.errors |= ((ANALOG_AGC_ACTION_CH1) << i);
                gains_changed = true;
            } else {
                state.base.errors |= (ANALOG_AGC_TOO_LOW_CH1 << i);
            }
        }
    }

    if (gains_changed) update_spec_gains();
    return gains_changed;
}

void process_gain_range() {
    if (spec_get_ADC_stat(state.base.ADC_stat)) {
        if (analog_gain_control()) {
            // gains have changed. wait for settle and trigger. 
            debug_print("Gains changed, resettle\n\r");
            resettle = true;
            resettle_counter = RESETTLE_DELAY;
        } else {
            if (range_adc) {
                range_adc = 0;
                housekeeping_request = 2;
             }
         }
    } else  {
        //if (range_adc) debug_print("not yet \n");
    }

    if ((resettle) & (resettle_counter == 0)) {
        trigger_ADC_stat();
        resettle = false;
        if (state.base.spectrometer_enable) {
            restart_spectrometer();
        }
    }
}
  
bool bitslice_control() {
    bool bitslice_changed = false;
    int32_t *ddr_ptr = (int32_t *) DDR3_BASE_ADDR;
    for (int i = 0; i < 4; i++) {
        if (state.seq.bitslice[i] != 0xFF) continue; // Don't do anything unless bitslice is auto
        uint8_t keep = 32-leading_zeros_max[i];
        if (keep>(state.seq.bitslice_keep_bits+1)) { 
            // we're keeping more bits than we should (with buffer of 1)
            // slicer should be increased
            state.base.actual_bitslice[i] += (keep-state.seq.bitslice_keep_bits);
            if (state.base.actual_bitslice[i] > 0x1F) {
                state.base.actual_bitslice[i] = 0x1F;
            }
            bitslice_changed = true;
        } else if (keep<(state.seq.bitslice_keep_bits-1)) {
            // we're keeping fewer bits than we should (with buffer of 1)
            // slicer should be decreased
            state.base.actual_bitslice[i] -= MIN(state.seq.bitslice_keep_bits-keep, state.base.actual_bitslice[i]);
            bitslice_changed = true;
        }
    }
    if (bitslice_changed) {

        uint8_t b1 = state.base.actual_bitslice[0];
        uint8_t b2 = state.base.actual_bitslice[1];
        uint8_t b3 = state.base.actual_bitslice[2];
        uint8_t b4 = state.base.actual_bitslice[3];

        if (state.seq.bitslice[4] == 0xFF) state.base.actual_bitslice[4]= (b1+b2)/2-1;
        if (state.seq.bitslice[5] == 0xFF) state.base.actual_bitslice[5]= (b1+b2)/2-1;
        if (state.seq.bitslice[6] == 0xFF) state.base.actual_bitslice[6]= (b1+b3)/2-1;
        if (state.seq.bitslice[7] == 0xFF) state.base.actual_bitslice[7]= (b1+b3)/2-1;
        if (state.seq.bitslice[8] == 0xFF) state.base.actual_bitslice[8]= (b1+b4)/2-1;
        if (state.seq.bitslice[9] == 0xFF) state.base.actual_bitslice[9]= (b1+b4)/2-1;
        if (state.seq.bitslice[10] == 0xFF) state.base.actual_bitslice[10]= (b2+b3)/2-1;
        if (state.seq.bitslice[11] == 0xFF) state.base.actual_bitslice[11]= (b2+b3)/2-1;
        if (state.seq.bitslice[12] == 0xFF) state.base.actual_bitslice[12]= (b2+b4)/2-1;
        if (state.seq.bitslice[13] == 0xFF) state.base.actual_bitslice[13]= (b2+b4)/2-1;
        if (state.seq.bitslice[14] == 0xFF) state.base.actual_bitslice[14]= (b3+b4)/2-1;
        if (state.seq.bitslice[15] == 0xFF) state.base.actual_bitslice[15]= (b3+b4)/2-1;
    }

    return bitslice_changed;
}

static inline int32_t get_with_zeros(int32_t val, uint8_t *min, uint8_t *max) {
    int32_t zeros = __builtin_clz(val);
    *min = MIN(*min, zeros);
    *max = MAX(*max, zeros);
    return val;
}

int16_t encode_12plus4(int32_t val) {
    int16_t out = 0;
    uint8_t lz = __builtin_clz(abs(val));
    if (lz>15) lz=15;
    // Super important: since the MSB after shifting is zero, we can skip it.
    out = (val >> (16-lz-1)) & 0xFFF0 + lz; // the first 12 bits are the actual value, the last 4 are the number of leading zeros.
    return out;
}

int32_t decode_12plus4(int16_t val) {
    int16_t out = 0;
    uint8_t lz = val & 0x0F;
    out = (0x0100+ (val & 0xFFF0)) << (16-lz-1);
    return out;
}


void transfer_from_df ()
{
// Want to now transfer all 16 pks worth of data to DDR memory
    int32_t *df_ptr = (int32_t *)SPEC_BUF;
    int32_t *ddr_ptr = tick_tock ? (int32_t *)(SPEC_TICK) : (int32_t *)(SPEC_TOCK);
    int32_t *ddr_ptr_previous = tick_tock ? (int32_t *)(SPEC_TOCK) : (int32_t *)(SPEC_TICK);
    uint16_t mask = 1;
    bool accept = true;
    if ((state.seq.reject_ratio>0) & (state.base.weight_previous>(state.Navg2/2))) {
        uint32_t bad = 0;
        for (uint16_t sp = 0; sp< NSPECTRA_AUTO; sp++) {
            if (state.base.corr_products_mask & (mask)) {
                for (uint16_t i = 0; i < NCHANNELS; i++) {
                    int32_t val = *df_ptr;
                    int32_t previous_val = *ddr_ptr_previous/state.base.weight_previous;            
                    if (abs(val-previous_val)>(previous_val/state.seq.reject_ratio)) {
                        bad++;
                    }
                    df_ptr++;
                    ddr_ptr_previous++;
                }
            } else {df_ptr+=NCHANNELS; ddr_ptr_previous+=NCHANNELS;}
            mask <<= 1;
        }   
        if (bad > state.seq.reject_maxbad)  accept = false;
        // reinitialize the pointers
        df_ptr = (int32_t *)SPEC_BUF;
        mask = 1;
    }

    if (accept) {
        state.base.weight_current ++;
        for (uint16_t sp = 0; sp< NSPECTRA; sp++) {
            leading_zeros_min[sp] = 32;
            leading_zeros_max[sp] = 0;
            if (state.base.corr_products_mask & (mask)) {
                if (sp < NSPECTRA_AUTO) {
                        for (uint16_t i = 0; i < NCHANNELS; i++) {
                            ddr_ptr+= get_with_zeros(*df_ptr, &leading_zeros_min[sp], &leading_zeros_max[sp]);
                            df_ptr++;
                            ddr_ptr++;
                        } 
                    } else {
                    for (uint16_t i = 0; i < NCHANNELS; i++) {                        
                        *ddr_ptr += (*df_ptr >> state.Navg2_total_shift);
                        df_ptr++;
                        ddr_ptr++;
                    }
                }
            } else {df_ptr+=NCHANNELS; ddr_ptr+=NCHANNELS;}        
            mask <<= 1;        
        }   
    }

    if (state.seq.tr_stop>state.seq.tr_start) {
        int16_t* tr = (int16_t *)(SPEC_TIME_RESOLVED + NCHANNELS*avg_counter*sizeof(int16_t));
        df_ptr = (int32_t *)SPEC_BUF;
        mask = 1;
        for (uint16_t sp = 0; sp< NSPECTRA; sp++) {
            if (state.base.corr_products_mask & (mask)) {
                int32_t *ddr_ptr = (int32_t *)(SPEC_TOCK) + sp*NCHANNELS + state.seq.tr_start;
                for (uint16_t i = state.seq.tr_start; i <state.seq.tr_stop; i+=state.tr_avg) {
                    uint32_t val = 0;
                    for (uint16_t j =0; j<state.tr_avg; j++) {
                        val += (*df_ptr << state.seq.tr_avg_shift);
                        df_ptr++;
                    }
                    *tr = encode_12plus4(val);
                }
            } else {df_ptr+=NCHANNELS;}
            mask <<= 1;
        }
    }

    //if (avg_counter%100 == 0) debug_print ("Processed 100 spectra...\n");
    avg_counter++;
}



uint32_t CRC(const void* data, size_t size) {
    const uint8_t* bytes = (const uint8_t*)data;
    uint32_t crc = 0xFFFFFFFF;

    for (size_t i = 0; i < size; i++) {
        crc ^= bytes[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc >>= 1;
            }
        }
    }

    return ~crc;
}

bool process_housekeeping() {
    if (housekeeping_request == 0) return false;
    housekeeping_request--; // go back to the original one
    struct housekeeping_data_base *base = (struct housekeeping_data_base *)TLM_BUF;
    wait_for_cdi_ready();
    base->version = VERSION_ID;
    base->unique_packet_id = unique_packet_id;
    base->errors = state.base.errors;
    base->housekeeping_type = housekeeping_request;

    switch (housekeeping_request) {
        case 0:
            debug_print ("Sending housekeeping type 0\n\r");
            struct housekeeping_data_0 *hk0 = (struct housekeeping_data_0 *)TLM_BUF;
            hk0->core_state = state;
            cdi_dispatch(AppID_uC_Housekeeping, sizeof(struct housekeeping_data_0));
            break;

        case 1:
            debug_print ("Sending housekeeping type 1\n\r");
            struct housekeeping_data_1 *hk1 = (struct housekeeping_data_1 *)TLM_BUF;
            for (int i=0; i<NINPUT; i++) {
                hk1->ADC_stat[i] = state.base.ADC_stat[i];
                hk1->actual_gain[i] = state.base.actual_gain[i];
            }
            cdi_dispatch(AppID_uC_Housekeeping, sizeof(struct housekeeping_data_1));
            break;

        case 99:
            debug_print ("Sending section break (hk 99)\n\r");
            struct housekeeping_data_99 *hk_99 = (struct housekeeping_data_99 *)TLM_BUF;
            hk_99->section_break = section_break++;
            cdi_dispatch(AppID_uC_Housekeeping, sizeof(struct housekeeping_data_99));
            break;
    }
    debug_print("E:");
    debug_print_dec(state.base.errors);
    debug_print("\n");

    housekeeping_request = 0;
    state.base.errors = 0;
    return true;
}


void send_metadata_packet() {
    struct meta_data *meta = (struct meta_data *)TLM_BUF;
    wait_for_cdi_ready();
    meta->version = VERSION_ID;
    meta->unique_packet_id = unique_packet_id;
    meta->seq = state.seq;
    meta->base = state.base;
    cdi_dispatch(AppID_MetaData, sizeof(struct meta_data));
    reset_errormasks();
}


void dispatch_32bit_data() {
    // if we are in tick, we are copyng over TOCK, otherwise TICK !!
    int32_t *ddr_ptr = tick_tock ? (int32_t *)(SPEC_TOCK) : (int32_t *)(SPEC_TICK);
    ddr_ptr += state.cdi_dispatch.prod_count * NCHANNELS; //state.Nfreq; // pointer to current block of data.
    int32_t *cdi_ptr = (int32_t *)TLM_BUF;
    int32_t *crc_ptr;

    *cdi_ptr = (int32_t)(state.cdi_dispatch.packet_id);
    cdi_ptr++;
    crc_ptr = cdi_ptr;
    cdi_ptr++;
    uint32_t data_size = state.cdi_dispatch.Nfreq*sizeof(int32_t);
    uint32_t packet_size = data_size+2*sizeof(int32_t);
    wait_for_cdi_ready();
    switch (state.cdi_dispatch.Navgf) {
        case 1:
            memcpy(cdi_ptr, ddr_ptr, state.cdi_dispatch.Nfreq * sizeof(uint32_t));
            break;
        case 2:
            for (int i = 0; i < state.cdi_dispatch.Nfreq; i++) {
                cdi_ptr[i] = ddr_ptr[i*2]<<1 + ddr_ptr[i*2+1]<<1;
            }
            break;
        case 3:
            for (int i = 0; i < state.cdi_dispatch.Nfreq; i++) {
                cdi_ptr[i] = ddr_ptr[i*4]<<2 + ddr_ptr[i*4+1]<<2 + ddr_ptr[i*4+2]<<2; 
            }
            break;
        case 4:
            for (int i = 0; i < state.cdi_dispatch.Nfreq; i++) {
                cdi_ptr[i] = ddr_ptr[i*4]<<2 + ddr_ptr[i*4+1]<<2 + ddr_ptr[i*4+2]<<2 + ddr_ptr[i*4+3]<<2;
            }
            break;
    }

    memset(ddr_ptr, 0, state.cdi_dispatch.Nfreq * sizeof(uint32_t));
    *crc_ptr = CRC(cdi_ptr, data_size);
    cdi_dispatch(state.cdi_dispatch.appId, packet_size);
}

void dispatch_16bit_updates_data() {
    cdi_not_implemented("16bit w updates data format");    
}

void dispatch_16bit_float1_data() {
    cdi_not_implemented("16bit w float1 data format");    
}

uint32_t get_next_baseAppID() {
    // constants from the C standard library implementation of LCG
    state.base.rand_state = 1103515245 * state.base.rand_state + 12345;
    uint8_t rand = state.base.rand_state & 0xFF;
    if (rand <= state.seq.hi_frac) {
        return AppID_SpectraHigh;
    } else if (rand <= state.seq.hi_frac + state.seq.med_frac) {
        return AppID_SpectraMed;
    } else {
        return AppID_SpectraLow;
    }
    // should never be here, really
    return AppID_SpectraLow;
}



void transfer_to_cdi () {
    debug_print ("Sending averaged spectra to CDI.\n\r");

    new_unique_packet_id();
    update_time();
    spec_get_TVS(state.base.TVS_sensors);
    send_metadata_packet();
    state.cdi_dispatch.int_counter = DISPATCH_DELAY; // 10*0.01s ~10 Hz
    state.cdi_dispatch.prod_count = 0; // 
    state.cdi_dispatch.Nfreq = state.Nfreq;
    state.cdi_dispatch.Navgf = state.seq.Navgf;
    state.cdi_dispatch.appId = get_next_baseAppID();
    state.cdi_dispatch.format = state.seq.format;
    state.cdi_dispatch.packet_id = unique_packet_id;

}

bool process_delayed_cdi_dispatch() {
    if (state.cdi_dispatch.int_counter > 0) return false;
    if (state.cdi_dispatch.prod_count > 0x0F)  return false;
    if (state.base.corr_products_mask & (1<<state.cdi_dispatch.prod_count)) {
        switch (state.cdi_dispatch.format) {
            case OUTPUT_32BIT:
                dispatch_32bit_data();
                break;
            case OUTPUT_16BIT_UPDATES:
                dispatch_16bit_updates_data();
                break;
            case OUTPUT_16BIT_FLOAT1:
                dispatch_16bit_float1_data();
                break;
            default:
                cdi_not_implemented("Unsupported output format");
                break;
        }
    }
    state.cdi_dispatch.prod_count++;
    state.cdi_dispatch.appId++;
    state.cdi_dispatch.int_counter = DISPATCH_DELAY;
    return true;
}


bool process_waveform() {
    if (!request_waveform) return false;
    wait_for_cdi_ready();
    spec_request_waveform(request_waveform & 3);
    request_waveform = 0;
    return true;
}

void advance_sequencer() {

state.base.sequencer_substep--;
if (state.base.sequencer_substep == 0) {
    state.base.sequencer_step = (state.base.sequencer_step+1)%state.program.Nseq;
    if (state.base.sequencer_step == 0) {
        state.base.sequencer_counter++;
        if ((state.program.sequencer_repeat>0) & (state.base.sequencer_counter == state.program.sequencer_repeat)) {
            //debug_print("Sequencer done.\n");
            RFS_stop();
        } else {
            //debug_print("Starting sequencer cycle # %i/%i\n", state.base.sequencer_counter+1, state.base.sequencer_repeat);
        }
    }
    
    state.base.sequencer_substep = state.program.seq_times[state.base.sequencer_step];
    bool restart = restart_needed(&state.seq, &state.program.seq[state.base.sequencer_step]); 
    if (restart) RFS_stop();
    state.seq = state.program.seq[state.base.sequencer_step];
    fill_derived();
    set_spectrometer_to_sequencer();
    if (restart) RFS_start();
    }      
}

static inline void process_spectrometer() {
// Check if we have a new spectrum packet from the FPGA
if (spec_new_spectrum_ready())
    {
        if (drop_df) {  // we were asked to drop a frame
            drop_df = false;
            spec_df_dropped(); // ignore any drooped so far
            spec_clear_df_flag();
        } else {
            if (spec_df_dropped()) state.base.errors |= DF_SPECTRA_DROPPED;
            trigger_ADC_stat();
            transfer_from_df();
            uint16_t corr_owf, notch_owf;
            spec_get_digital_overflow(&corr_owf, &notch_owf);
            state.base.spec_overflow |= corr_owf;
            state.base.notch_overflow |= notch_owf;

            spec_clear_df_flag(); // Clear the flag to indicate that we have read the data
            bool bit_slice_changed = bitslice_control();
            if (bit_slice_changed) {
                restart_spectrometer(); // Restart the spectrometer if the bit slice has changed; avg_counter will be reset so we don't need to worry about triggering the CDI write
            }

            // Check if we have reached filled up Stage 2 averaging
            // and if so, push things out to CDI
            if (avg_counter == state.Navg2)
            {
                avg_counter = 0;
                tick_tock = !tick_tock;
                state.base.weight_previous = state.base.weight_current;
                state.base.weight_current = 0;
                // Now one by one, we will loop through the packets placed in DDR Memory
                // For each channel, set the APID, send it to the SRAM
                // Then check to see if this software or the client will control the CDI writes
                transfer_to_cdi();
                if (state.sequencer_enabled) advance_sequencer();

            }
        }
    }
}




void restore_state() {
    uint32_t arg1 = spec_read_uC_register(0);  // register contains argumed passed from bootloader
    if (arg1 == 1) {
        debug_print("Ignoring saved states\r\n");
        return;
    } else if (arg1==2) {
        // remove all slots
        for (int i=0; i<MAX_STATE_SLOTS; i++) {
            debug_print("Deleting slot ");
            debug_print_dec(i);
            debug_print("\r\n");
            flash_state_clear(i);
            while (flash_clear>0) {}
        }
        return;
    }

    flash_store_pointer == 0;
    while (!flash_state_restore(flash_store_pointer)) {
        flash_store_pointer++;
        if (flash_store_pointer == MAX_STATE_SLOTS) {
            // ideally start with a random store to avoid flash wear, but at this point we have nothing.
            flash_store_pointer = 0;
            return;
        }
    }
    debug_print("Restored existing state from slot ")
    debug_print_dec(flash_store_pointer);
    debug_print("\r\n");
    if (state.base.spectrometer_enable) {
        RFS_start();
    }
    
}


void core_loop()
{
    soft_reset_flag = false;
    request_waveform = 0 ;
    range_adc = 0;
    section_break = 0;
    flash_clear = 0;
    flash_size = 0;
    flash_write = 0;
    flash_wait = 0;
    send_hello_packet();
    core_init_state();
    // restore state from flash if unscheduled reset occured
    restore_state();

    for (;;)
    {
        update_time();
        // Check if we have a new CDI command and process it.
        // If this functions returns true, it means we got the time-to-die command
        if (process_cdi()) break;
        process_spectrometer();
        process_gain_range();
        // we always process just one CDI interfacing things
        process_hearbeat() | process_delayed_cdi_dispatch() | process_housekeeping() | process_waveform();

#ifdef NOTREAL
        // if we are running inside the coreloop test harness.
uint8_t      MSYS_EI5_IRQHandler();
          MSYS_EI5_IRQHandler();
#endif
    }
}

uint8_t MSYS_EI5_IRQHandler(void)
{

    uint32_t tocpy;
    /* Clear the interrupt within the timer */
    if (resettle_counter > 0) resettle_counter--;   
    if (state.cdi_dispatch.int_counter > 0) state.cdi_dispatch.int_counter--;
    if (heartbeat_counter > 0) heartbeat_counter--;
     // flash processing.
    if (flash_wait>0) {
        flash_wait --;
    } else if (flash_clear>0) {
        /*debug_print("flash clear ")
        debug_print_dec(flash_clear);
        debug_print("\r\n");*/
        switch (flash_clear) {
            case 3:
                SPI_4k_erase_step1(flash_addr);
                break;
            case 2:
                SPI_4k_erase_step2();
                break;
            case 1:
                SPI_4k_erase_step3();
                break;
        }
        flash_clear --;
        flash_wait = 1;
    } else if (flash_size>0) {
        // after we cleared we can write if needed
      if (flash_write == 0) flash_write = 4;
      /*debug_print("flash write ")
      debug_print_dec(flash_write);
      debug_print (" ");
      debug_print_dec(flash_size);
      debug_print (" ");
      debug_print_hex(flash_addr);
      debug_print (" ");
      uint32_t *v = (uint32_t *)flash_buf;
      debug_print_hex(*v);
      debug_print("\r\n");*/
      switch (flash_write) {
          case 4:
              //int tocpy;
              tocpy = (flash_size<=256) ? flash_size : 256;
              //print_buf(flash_buf,50);
              //memcpy (SFL_WR_BUFF, flash_buf, tocpy);
              uint8_t *src = (uint8_t*) flash_buf;
              uint8_t *tgt = (uint8_t*) SFL_WR_BUFF;
              for (int i=0; i<tocpy; i++) tgt[i]=src[i];
              //print_buf(SFL_WR_BUFF,50);
              break;
          case 3:
              //debug_print (" ");
              ///uint32_t *v = (uint32_t *)SFL_WR_BUFF;
              //debug_print_hex(*v);
              //debug_print("\r\n");
              SPI_write_page_step1(flash_addr);
              break;
          case 2:
              SPI_write_page_step2();
              break;
          case 1:
              SPI_write_page_step3();
              if (flash_size>256) flash_size-=256; else flash_size=0;
              flash_addr+=256;
              flash_buf+=256;
              break;
      }
      flash_write --;
      flash_wait = 1;
  }


    TMR_clear_int(&g_core_timer_0);
    return (EXT_IRQ_KEEP_ENABLED);
}
